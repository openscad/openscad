diff --git a/CMakeLists.txt b/CMakeLists.txt
index d9bd6638..70f4ef8c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -329,6 +329,7 @@ set(CORE_SOURCES
   src/dxfdata.cc 
   src/dxfdim.cc 
   src/offset.cc 
+  src/extrude.cc
   src/linearextrude.cc 
   src/rotateextrude.cc 
   src/text.cc 
diff --git a/openscad.pro b/openscad.pro
index 739a35cd..328d8dd5 100755
--- a/openscad.pro
+++ b/openscad.pro
@@ -313,6 +313,7 @@ HEADERS += src/version_check.h \
            src/node.h \
            src/csgnode.h \
            src/offsetnode.h \
+           src/extrudenode.h \
            src/linearextrudenode.h \
            src/rotateextrudenode.h \
            src/projectionnode.h \
@@ -454,6 +455,7 @@ SOURCES += \
            src/dxfdata.cc \
            src/dxfdim.cc \
            src/offset.cc \
+           src/extrude.cc \
            src/linearextrude.cc \
            src/rotateextrude.cc \
            src/printutils.cc \
diff --git a/src/GeometryEvaluator.cc b/src/GeometryEvaluator.cc
index 1da69358..7d2a0f5c 100644
--- a/src/GeometryEvaluator.cc
+++ b/src/GeometryEvaluator.cc
@@ -8,6 +8,7 @@
 #include "state.h"
 #include "offsetnode.h"
 #include "transformnode.h"
+#include "extrudenode.h"
 #include "linearextrudenode.h"
 #include "rotateextrudenode.h"
 #include "csgnode.h"
@@ -598,17 +599,22 @@ Response GeometryEvaluator::visit(State &state, const TransformNode &node)
 						if (res.isConst()) newpoly.reset(new Polygon2d(*polygons));
 						else newpoly = dynamic_pointer_cast<Polygon2d>(res.ptr());
 						
-						Transform2d mat2;
-						mat2.matrix() << 
-							node.matrix(0,0), node.matrix(0,1), node.matrix(0,3),
-							node.matrix(1,0), node.matrix(1,1), node.matrix(1,3),
-							node.matrix(3,0), node.matrix(3,1), node.matrix(3,3);
-						newpoly->transform(mat2);
-						// A 2D transformation may flip the winding order of a polygon.
-						// If that happens with a sanitized polygon, we need to reverse
-						// the winding order for it to be correct.
-						if (newpoly->isSanitized() && mat2.matrix().determinant() <= 0) {
-							geom.reset(ClipperUtils::sanitize(*newpoly));
+						geom = newpoly;
+						if (Feature::ExperimentalExtrude.is_enabled())
+							newpoly->transform3d(node.matrix);
+						else {
+							Transform2d mat2;
+							mat2.matrix() <<
+							   node.matrix(0,0), node.matrix(0,1), node.matrix(0,3),
+							   node.matrix(1,0), node.matrix(1,1), node.matrix(1,3),
+							   node.matrix(3,0), node.matrix(3,1), node.matrix(3,3);
+							newpoly->transform(mat2);
+							// A 2D transformation may flip the winding order of a polygon.
+							// If that happens with a sanitized polygon, we need to reverse
+							// the winding order for it to be correct.
+							if (newpoly->isSanitized() && mat2.matrix().determinant() <= 0) {
+							   geom.reset(ClipperUtils::sanitize(*newpoly));
+							}
 						}
 					}
 					else if (geom->getDimension() == 3) {
@@ -644,6 +650,211 @@ Response GeometryEvaluator::visit(State &state, const TransformNode &node)
 	return Response::ContinueTraversal;
 }
 
+/* Returns whether travel from p0 => p1 is a negative, zero, or positive distance
+ * in the direction of the extusion, with respect to p0's plane.
+ */
+inline int check_extrusion_progression(const Vector3d &p0, const Vector3d &p1, const Vector3d &plane_abc, double plane_d, double equality_tolerance) {
+	// point is clearly above the plane?
+	double plane_dist= plane_abc.dot(p1) + plane_d;
+	if (plane_dist > equality_tolerance)
+		return 1;
+	// point lies on the plane, and is same as previous point?
+	else if (plane_dist > -equality_tolerance && (p1 - p0).squaredNorm() < equality_tolerance)
+		return 0;
+	// point crossed the plane, or lies on the plane and isn't the same point.
+	else
+		return -1;
+}
+
+static void expand_poly2d_to_ccw3d(const class Polygon2d *poly2d, PolySet *polyset) {
+	polyset->polygons.clear();
+	// unpack all the 2D coordinates into 3D vectors with Z=0
+	for (const auto &outline : poly2d->untransformedOutlines()) {
+		polyset->append_poly();
+		for (const auto &vtx : outline.vertices)
+			polyset->append_vertex(vtx[0], vtx[1], 0);
+		// Make sure winding order is CCW
+		//if (polyset->polygons.back().size() > 2) {
+		//	Vector3d ab = polyset->polygons.back()[1] - polyset->polygons.back()[0];
+		//	Vector3d bc = polyset->polygons.back()[2] - polyset->polygons.back()[1];
+		//	if (ab.cross(bc).z() < 0) {
+		//		// Reverse the winding
+		//		std::reverse(polyset->polygons.back().begin(), polyset->polygons.back().end());
+		//	}
+		//}
+	}
+	polyset->transform(poly2d->getTransform3d());
+}
+
+/*!
+	input: List of 2D objects arranged in 3D, each with identical outline count and vertex count
+	output: 3D PolySet
+ */
+shared_ptr<const Geometry> extrudePolygonSequence(const ExtrudeNode &node, std::vector<const class Polygon2d *> slices, const std::string &loc)
+{
+	size_t i, p, v;
+	const double CLOSE_ENOUGH = 0.00000000000000001; // tolerance for identical coordinates
+
+	// Verify there is something to work with
+	if (slices.size() < 2) {
+		PRINTB("ERROR: %s requires at least two slices, %s", node.name() % loc);
+		return nullptr;
+	}
+	
+	// Verify that every slice has the same number of contours with the same number of vetices
+	for (i= 1; i < slices.size(); i++) {
+		bool match = slices[i]->untransformedOutlines().size() == slices[0]->untransformedOutlines().size();
+		for (p = 0; match && p < slices[i]->untransformedOutlines().size(); p++)
+			match = slices[i]->untransformedOutlines()[p].vertices.size() == slices[0]->untransformedOutlines()[p].vertices.size();
+		if (!match) {
+			PRINTB("ERROR: Each extrusion slice must have exactly the same number of polygons of the same vertex count, %s\n"
+				"(note that polygon sanitization may remove duplicate vertices or co-linear points)", loc);
+			// Collect details to help debug
+			std::stringstream desc_0, desc_i;
+			for (const auto &o : slices[0]->untransformedOutlines()) desc_0 << " " << o.vertices.size() << "vtx";
+			for (const auto &o : slices[i]->untransformedOutlines()) desc_i << " " << o.vertices.size() << "vtx";
+			PRINTB(" slice   0 - %2d outlines: %s", slices[0]->untransformedOutlines().size() % desc_0.str().c_str());
+			PRINTB(" slice %3d - %2d outlines: %s", i % slices[i]->untransformedOutlines().size() % desc_i.str().c_str());
+			return nullptr;
+		}
+	}
+
+	// Start extruding slices.  Come back to "end caps" at the end.
+	int reversed= 0;
+	PolySet tmp0(3), tmp1(3), tmp2(3), *result = new PolySet(3, unknown);
+	result->setConvexity(node.convexity);
+	// Unroll first iteration so we have a "prev" to work with, and so we can use it again at the end
+	expand_poly2d_to_ccw3d(slices[0], &tmp0);
+	
+	PolySet *cur = &tmp1, *prev = &tmp0;
+	int progression= 0;
+	for (i = 1; i < slices.size(); i++, prev = cur, cur = (cur == &tmp1? &tmp2 : &tmp1)) {
+		const Transform3d &cur_mat = slices[i]->getTransform3d();
+		const Transform3d &prev_mat = slices[i-1]->getTransform3d();
+		// Build new polygon set in 3D from 2D outlines
+		expand_poly2d_to_ccw3d(slices[i], cur);
+		// Plane equations for these matrices
+		Vector3d cur_origin(cur_mat * Vector3d(0,0,0));
+		Vector3d cur_abc(cur_mat * Vector3d(0,0,1) - cur_origin);
+		double cur_d = - (cur_abc.dot(cur_origin));
+		Vector3d prev_origin(prev_mat * Vector3d(0,0,0));
+		Vector3d prev_abc(prev_mat * Vector3d(0,0,1) - prev_origin);
+		double prev_d = - (prev_abc.dot(prev_origin));
+
+		
+		// Decide whether to reverse the list of slices.  Each slice should be located within
+		// +Z of previous, but it's easy to get that backward, and annoying to the user to have
+		// to fix it.  This could also be a result of fixing the winding order of the polygons.
+		if (i == 1 && !reversed) {
+			// Take a guess based on the first point that isn't on this plane
+			// (a point from slice 0 can appear on the plane of slice 1 if they share an axis)
+			int direction = 0;
+			for (p = 0; !direction && p < cur->polygons.size(); p++)
+				for (v = 0; !direction && v < cur->polygons[p].size(); v++)
+					direction = check_extrusion_progression(
+						prev->polygons[p][v],
+						cur->polygons[p][v],
+						prev_abc, prev_d, CLOSE_ENOUGH
+					);
+			// If negative direction, reverse the list and restart the loop
+			if (direction < 0) {
+				std::reverse(slices.begin(), slices.end());
+				i = 0;
+				reversed = 1;
+				// Need to re-calculate the starting points for slice 0
+				cur = &tmp0;
+				expand_poly2d_to_ccw3d(slices[0], cur);
+				continue;
+			}
+		}
+
+		// If final slice looks mostly identical to first slice, then connect it to the first slice
+		if (i == slices.size()-1) {
+			bool closed_loop = true;
+			for (p = 0; closed_loop && p < cur->polygons.size(); p++) {
+				for (v = 0; closed_loop && v < cur->polygons[p].size(); v++) {
+					closed_loop = fabs(tmp0.polygons[p][v][0] - cur->polygons[p][v][0]) < CLOSE_ENOUGH
+					           && fabs(tmp0.polygons[p][v][1] - cur->polygons[p][v][1]) < CLOSE_ENOUGH
+					           && fabs(tmp0.polygons[p][v][2] - cur->polygons[p][v][2]) < CLOSE_ENOUGH;
+				}
+			}
+			if (closed_loop) // use exact original coordinates
+				cur = &tmp0;
+			else { // else need to append end-cap polygons
+				// Always progress in +Z direction, so start needs reversed, and end does not.
+				PolySet *start = slices[0]->tessellate(true);
+				for(auto &p : start->polygons) std::reverse(p.begin(), p.end());
+				result->append(*start);
+				delete start;
+
+				PolySet *end = slices[i]->tessellate(true);
+				result->append(*end);
+				delete end;
+			}
+		}
+		
+		// For each pair of adjacent vertices on each of the current and previous
+		// polygons, build a quad between them using two triangles.  However, check if the
+		// slices share a vertex like will happen if extruding around an axis, and in those
+		// cases either make one triangle or exclude the polygon entirely.
+		for (p = 0; p < cur->polygons.size() && progression >= 0; p++) {
+			size_t v0 = cur->polygons[p].size()-1;
+			// previous vertex must be -Z of current plane
+			progression= -check_extrusion_progression(cur->polygons[p][v0], prev->polygons[p][v0], cur_abc, cur_d, CLOSE_ENOUGH);
+			if (progression < 0) break;
+			// next vertex must be +Z of previous plane
+			progression = check_extrusion_progression(prev->polygons[p][v0], cur->polygons[p][v0], prev_abc, prev_d, CLOSE_ENOUGH);
+			int v0_progression= progression;
+			for (size_t v1 = 0; v1 < cur->polygons[p].size() && progression >= 0; v0 = v1, ++v1) {
+				// previous vertex must be -Z of current plane
+				progression= -check_extrusion_progression(cur->polygons[p][v1], prev->polygons[p][v1], cur_abc, cur_d, CLOSE_ENOUGH);
+				if (progression < 0) break;
+				// next vertex must be +Z of previous plane
+				progression = check_extrusion_progression(prev->polygons[p][v1], cur->polygons[p][v1], prev_abc, prev_d, CLOSE_ENOUGH);
+				
+				if (v0_progression > 0) {
+					result->append_poly();
+					result->append_vertex(cur->polygons[p][v0]);
+					result->append_vertex(prev->polygons[p][v0]);
+					result->append_vertex(prev->polygons[p][v1]);
+				}
+				if (progression > 0) {
+					result->append_poly();
+					result->append_vertex(prev->polygons[p][v1]);
+					result->append_vertex(cur->polygons[p][v1]);
+					result->append_vertex(cur->polygons[p][v0]);
+				}
+				v0_progression = progression;
+			}
+		}
+		if (progression < 0) break;
+	}
+	if (progression < 0) {
+		PRINTB("ERROR: An extrusion slice must not intersect the plane of its neighbors"
+               " (collision at slice %d), %s", (reversed? slices.size()-1-i : i) % loc);
+		delete result;
+		return nullptr;
+	}
+	return shared_ptr<const Geometry>(result);
+}
+
+/*!
+	input: List of 2D objects arranged in 3D, each with identical outline count and vertex count
+	output: 3D PolySet
+ */
+Response GeometryEvaluator::visit(State &state, const ExtrudeNode &node)
+{
+	if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+	if (state.isPostfix()) {
+		std::string loc = node.modinst->location().toRelativeString(this->tree.getDocumentPath());
+		shared_ptr<const Geometry> geom = isSmartCached(node)? smartCacheGet(node, false)
+			: extrudePolygonSequence(node, collectChildren2D(node), loc);
+		addToParent(state, node, geom);
+		node.progress_report();
+	}
+	return Response::ContinueTraversal;
+}
+
 static void translate_PolySet(PolySet &ps, const Vector3d &translation)
 {
 	for(auto &p : ps.polygons) {
diff --git a/src/GeometryEvaluator.h b/src/GeometryEvaluator.h
index a398611d..31728272 100644
--- a/src/GeometryEvaluator.h
+++ b/src/GeometryEvaluator.h
@@ -21,6 +21,7 @@ public:
 	Response visit(State &state, const AbstractNode &node) override;
 	Response visit(State &state, const AbstractIntersectionNode &node) override;
 	Response visit(State &state, const AbstractPolyNode &node) override;
+	Response visit(State &state, const ExtrudeNode &node) override;
 	Response visit(State &state, const LinearExtrudeNode &node) override;
 	Response visit(State &state, const RotateExtrudeNode &node) override;
 	Response visit(State &state, const GroupNode &node) override;
diff --git a/src/NodeVisitor.h b/src/NodeVisitor.h
index 139208d0..03863d1a 100644
--- a/src/NodeVisitor.h
+++ b/src/NodeVisitor.h
@@ -14,6 +14,7 @@ class NodeVisitor :
 	public Visitor<class LeafNode>,
 	public Visitor<class CgaladvNode>,
 	public Visitor<class CsgOpNode>,
+	public Visitor<class ExtrudeNode>,
 	public Visitor<class LinearExtrudeNode>,
 	public Visitor<class RotateExtrudeNode>,
 	public Visitor<class ImportNode>,
@@ -54,6 +55,9 @@ public:
   Response visit(class State &state, const class CsgOpNode &node) override {
 		return visit(state, (const class AbstractNode &)node);
 	}
+  Response visit(class State &state, const class ExtrudeNode &node) override {
+		return visit(state, (const class AbstractPolyNode &)node);
+	}
   Response visit(class State &state, const class LinearExtrudeNode &node) override {
 		return visit(state, (const class AbstractPolyNode &)node);
 	}
diff --git a/src/Polygon2d-CGAL.cc b/src/Polygon2d-CGAL.cc
index 83290ca2..b575abea 100644
--- a/src/Polygon2d-CGAL.cc
+++ b/src/Polygon2d-CGAL.cc
@@ -87,7 +87,7 @@ mark_domains(CDT &cdt)
 /*!
 	Triangulates this polygon2d and returns a 2D PolySet.
 */
-PolySet *Polygon2d::tessellate() const
+PolySet *Polygon2d::tessellate(bool in3d) const
 {
 	PRINTDB("Polygon2d::tessellate(): %d outlines", this->outlines().size());
 	auto polyset = new PolySet(*this);
@@ -98,7 +98,7 @@ PolySet *Polygon2d::tessellate() const
 	try {
 
 	// Adds all vertices, and add all contours as constraints.
-	for (const auto &outline : this->outlines()) {
+	for (const auto &outline : (in3d? this->untransformedOutlines() : this->outlines())) {
 		// Start with last point
 		auto prev = cdt.insert({outline.vertices[outline.vertices.size()-1][0], outline.vertices[outline.vertices.size()-1][1]});
 		for (const auto &v : outline.vertices) {
@@ -131,5 +131,7 @@ PolySet *Polygon2d::tessellate() const
 			}
 		}
 	}
+	if (in3d)
+		polyset->transform(this->getTransform3d());
 	return polyset;
 }
diff --git a/src/Polygon2d.cc b/src/Polygon2d.cc
index f50ca267..09a33a7f 100644
--- a/src/Polygon2d.cc
+++ b/src/Polygon2d.cc
@@ -1,5 +1,6 @@
 #include "Polygon2d.h"
 #include "printutils.h"
+#include "feature.h"
 
 /*!
 	Class for holding 2D geometry.
@@ -19,7 +20,10 @@
 size_t Polygon2d::memsize() const
 {
 	size_t mem = 0;
-	for (const auto &o : this->outlines()) {
+	for (const auto &o : this->theoutlines) {
+		mem += o.vertices.size() * sizeof(Vector2d) + sizeof(Outline2d);
+	}
+	for (const auto &o : this->trans3dOutlines) {
 		mem += o.vertices.size() * sizeof(Vector2d) + sizeof(Outline2d);
 	}
 	mem += sizeof(Polygon2d);
@@ -29,6 +33,7 @@ size_t Polygon2d::memsize() const
 BoundingBox Polygon2d::getBoundingBox() const
 {
 	BoundingBox bbox;
+	// Note: this uses ->outlines, and so automatically gets trans3d applied
 	for (const auto &o : this->outlines()) {
 		for (const auto &v : o.vertices) {
 			bbox.extend(Vector3d(v[0], v[1], 0));
@@ -47,6 +52,20 @@ std::string Polygon2d::dump() const
 		}
 		out << "\n";
 	}
+	if (trans3dState != Transform3dState::NONE) {
+		out << "with trans3d: [";
+		for (int j=0;j<4;j++) {
+			out << "[";
+			for (int i=0;i<4;i++) {
+				double v(this->trans3d(j, i));
+				out << v;
+				if (i != 3) out << ", ";
+			}
+			out << "]";
+			if (j != 3) out << ", ";
+		}
+		out << "]\n";
+	}
 	return out.str();
 }
 
@@ -60,8 +79,10 @@ void Polygon2d::transform(const Transform2d &mat)
 	if (mat.matrix().determinant() == 0) {
 		PRINT("WARNING: Scaling a 2D object with 0 - removing object");
 		this->theoutlines.clear();
+		trans3dState= Transform3dState::NONE;
 		return;
 	}
+	if (trans3dState != Transform3dState::NONE) mergeTrans3d();
 	for (auto &o : this->theoutlines) {
 		for (auto &v : o.vertices) {
 			v = mat * v;
@@ -69,6 +90,44 @@ void Polygon2d::transform(const Transform2d &mat)
 	}
 }
 
+void Polygon2d::transform3d(const Transform3d &mat)
+{
+	// Check whether it can be a 2d transform, and avoid the 3d overhead
+	if (trans3dState == Transform3dState::NONE
+		&& mat(2,0) == 0 && mat(2,1) == 0 && mat(2,2) == 1 && mat(2,3) == 0
+		&& mat(0,2) == 0 && mat(1,2) == 0 && mat(3,2) == 0
+	) {
+		Transform2d t;
+		t.matrix() <<
+			mat(0,0), mat(0,1), mat(0,3),
+			mat(1,0), mat(1,1), mat(1,3),
+			mat(3,0), mat(3,1), mat(3,3);
+		if (t.matrix().determinant() == 0) {
+			PRINT("WARNING: Scaling a 2D object with 0 - removing object");
+			this->theoutlines.clear();
+			trans3dState= Transform3dState::NONE;
+			return;
+		}
+		transform(t);
+		// A 2D transformation may flip the winding order of a polygon.
+		// If that happens with a sanitized polygon, we need to reverse
+		// the winding order for it to be correct.
+		if (Feature::ExperimentalExtrude.is_enabled() && sanitized && t.matrix().determinant() < 0)
+			for (auto &o : this->theoutlines)
+				std::reverse(o.vertices.begin(), o.vertices.end());
+	}
+	else {
+		if (mat.matrix().determinant() == 0) {
+			PRINT("WARNING: Scaling a 2D object with 0 - removing object");
+			this->theoutlines.clear();
+			trans3dState= Transform3dState::NONE;
+			return;
+		}
+		trans3d= (trans3dState == Transform3dState::NONE)? mat : mat * trans3d;
+		trans3dState= Transform3dState::PENDING;
+	}
+}
+
 void Polygon2d::resize(const Vector2d &newsize, const Eigen::Matrix<bool,2,1> &autosize)
 {
 	auto bbox = this->getBoundingBox();
@@ -112,3 +171,48 @@ bool Polygon2d::is_convex() const
 	return true;
 }
 
+// This returns the outlines after applying any Transform3d that might be Transform3dState::PENDING.
+// If there is no Transform3d, this returns the outlines vector.
+// If there is a Transform3dState::CACHED Transform3d, this uses the cache.
+// Else it creates and returns the cache
+const Polygon2d::Outlines2d &Polygon2d::transformedOutlines() const {
+	if (trans3dState == Transform3dState::NONE) return theoutlines;
+	if (trans3dState != Transform3dState::CACHED) {
+		// Need to remove const from the cache object.  It maintains proper const semantics to the public API though.
+		Polygon2d::Outlines2d &cache= const_cast<Polygon2d::Outlines2d&>(trans3dOutlines);
+		cache= theoutlines;
+		applyTrans3dToOutlines(cache);
+		const_cast<Polygon2d*>(this)->trans3dState= Transform3dState::CACHED;
+	}
+	return trans3dOutlines;
+}
+
+// This flattens the 3D transform into the 2D transform that it would have been
+// originally.
+void Polygon2d::mergeTrans3d() {
+	if (trans3dState == Transform3dState::CACHED)
+		theoutlines.swap(trans3dOutlines);
+	else if (trans3dState == Transform3dState::PENDING)
+		applyTrans3dToOutlines(theoutlines);
+	trans3dOutlines.clear();
+	trans3dState= Transform3dState::NONE;
+}
+
+void Polygon2d::applyTrans3dToOutlines(Polygon2d::Outlines2d &outlines) const {
+	Transform2d t;
+	t.matrix() <<
+		trans3d(0,0), trans3d(0,1), trans3d(0,3),
+		trans3d(1,0), trans3d(1,1), trans3d(1,3),
+		trans3d(3,0), trans3d(3,1), trans3d(3,3);
+	for (auto &o : outlines) {
+		for (auto &v : o.vertices) {
+			v = t * v;
+		}
+	}
+	// A 2D transformation may flip the winding order of a polygon.
+	// If that happens with a sanitized polygon, we need to reverse
+	// the winding order for it to be correct.
+	if (Feature::ExperimentalExtrude.is_enabled() && sanitized && t.matrix().determinant() < 0)
+		for (auto &o : outlines)
+			std::reverse(o.vertices.begin(), o.vertices.end());
+}
diff --git a/src/Polygon2d.h b/src/Polygon2d.h
index e0416a90..b0009fb4 100644
--- a/src/Polygon2d.h
+++ b/src/Polygon2d.h
@@ -16,8 +16,9 @@ struct Outline2d {
 
 class Polygon2d : public Geometry
 {
+	enum class Transform3dState { NONE= 0, PENDING= 1, CACHED= 2 };
 public:
-	Polygon2d() : sanitized(false) {}
+	Polygon2d() : sanitized(false), trans3dState(Transform3dState::NONE) {}
 	size_t memsize() const override;
 	BoundingBox getBoundingBox() const override;
 	std::string dump() const override;
@@ -25,13 +26,26 @@ public:
 	bool isEmpty() const override;
 	Geometry *copy() const override { return new Polygon2d(*this); }
 
-	void addOutline(const Outline2d &outline) { this->theoutlines.push_back(outline); }
-	class PolySet *tessellate() const;
+	void addOutline(const Outline2d &outline) {
+		if (trans3dState != Transform3dState::NONE) mergeTrans3d();
+		this->theoutlines.push_back(outline);
+	}
+	class PolySet *tessellate(bool in3d= false) const;
 
 	typedef std::vector<Outline2d> Outlines2d;
-	const Outlines2d &outlines() const { return theoutlines; }
+	const Outlines2d &outlines() const { return trans3dState == Transform3dState::NONE? theoutlines : transformedOutlines(); }
+	const Outlines2d &untransformedOutlines() const { return theoutlines; }
+	const Outlines2d &transformedOutlines() const;
 
 	void transform(const Transform2d &mat);
+	void transform3d(const Transform3d &mat);
+	bool hasTransform3d() { return trans3dState != Transform3dState::NONE; }
+	const Transform3d &getTransform3d() const {
+		// lazy initialization doesn't actually violate 'const'
+		if (trans3dState == Transform3dState::NONE)
+			const_cast<Polygon2d*>(this)->trans3d= Transform3d::Identity();
+		return trans3d;
+	}
 	void resize(const Vector2d &newsize, const Eigen::Matrix<bool,2,1> &autosize);
 
 	bool isSanitized() const { return this->sanitized; }
@@ -40,4 +54,10 @@ public:
 private:
 	Outlines2d theoutlines;
 	bool sanitized;
+
+	Transform3dState trans3dState;
+	Transform3d trans3d;
+	Outlines2d trans3dOutlines;
+	void mergeTrans3d();
+	void applyTrans3dToOutlines(Polygon2d::Outlines2d &outlines) const;
 };
diff --git a/src/builtin.cc b/src/builtin.cc
index a4e8d564..73364b49 100644
--- a/src/builtin.cc
+++ b/src/builtin.cc
@@ -42,6 +42,7 @@ extern void register_builtin_import();
 extern void register_builtin_projection();
 extern void register_builtin_cgaladv();
 extern void register_builtin_offset();
+extern void register_builtin_extrude();
 extern void register_builtin_dxf_linear_extrude();
 extern void register_builtin_dxf_rotate_extrude();
 extern void register_builtin_text();
@@ -68,6 +69,7 @@ void Builtins::initialize()
 	register_builtin_projection();
 	register_builtin_cgaladv();
 	register_builtin_offset();
+	register_builtin_extrude();
 	register_builtin_dxf_linear_extrude();
 	register_builtin_dxf_rotate_extrude();
 	register_builtin_text();
diff --git a/src/control.cc b/src/control.cc
index 7452eb34..92c19de0 100644
--- a/src/control.cc
+++ b/src/control.cc
@@ -99,7 +99,16 @@ void ControlModule::for_eval(AbstractNode &node, const ModuleInstantiation &inst
                         });
                 }
 		else if (it_values->type() != Value::ValueType::UNDEFINED) {
-			c.set_variable(it_name, it_values);
+			// special case: if user appends "union=false" then pass all child nodes
+			// of for() loop to the parent node as if they were declared there.
+			GroupNode *gr;
+			if (Feature::ExperimentalExtrude.is_enabled()
+				&& it_name == "union" && it_values->type() == Value::ValueType::BOOL
+				&& (gr = dynamic_cast<GroupNode*>(&node))
+			)
+				gr->impliedUnion = it_values->toBool();
+			else
+				c.set_variable(it_name, it_values);
 			for_eval(node, inst, l+1, &c, evalctx);
 		}
 	} else if (l > 0) {
diff --git a/src/extrude.cc b/src/extrude.cc
new file mode 100644
index 00000000..4a10034c
--- /dev/null
+++ b/src/extrude.cc
@@ -0,0 +1,85 @@
+/*
+ *  OpenSCAD (www.openscad.org)
+ *  Copyright (C) 2009-2011 Clifford Wolf <clifford@clifford.at> and
+ *                          Marius Kintel <marius@kintel.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  As a special exception, you have permission to link this program
+ *  with the CGAL library and distribute executables, as long as you
+ *  follow the requirements of the GNU GPL in regard to all of the
+ *  software in the executable aside from CGAL.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "extrudenode.h"
+
+#include "module.h"
+#include "ModuleInstantiation.h"
+#include "evalcontext.h"
+#include "printutils.h"
+#include "fileutils.h"
+#include "builtin.h"
+#include "calc.h"
+#include "polyset.h"
+#include "handle_dep.h"
+
+#include <cmath>
+#include <sstream>
+#include <boost/assign/std/vector.hpp>
+using namespace boost::assign; // bring 'operator+=()' into scope
+
+class ExtrudeModule : public AbstractModule
+{
+public:
+	ExtrudeModule() : AbstractModule(Feature::ExperimentalExtrude) { }
+	AbstractNode *instantiate(const Context *ctx, const ModuleInstantiation *inst, EvalContext *evalctx) const override;
+};
+
+AbstractNode *ExtrudeModule::instantiate(const Context *ctx, const ModuleInstantiation *inst, EvalContext *evalctx) const
+{
+	auto node = new ExtrudeNode(inst);
+
+	AssignmentList args{};
+	AssignmentList optargs{Assignment("convexity")};
+
+	Context c(ctx);
+	c.setVariables(evalctx, args, optargs);
+	inst->scope.apply(*evalctx);
+
+	auto convexity = c.lookup_variable("convexity", true);
+	node->convexity = static_cast<int>(convexity->toDouble());
+	if (node->convexity <= 0)
+		node->convexity = 1;
+
+	auto instantiatednodes = inst->instantiateChildren(evalctx);
+	node->children.insert(node->children.end(), instantiatednodes.begin(), instantiatednodes.end());
+	return node;
+}
+
+std::string ExtrudeNode::toString() const
+{
+	std::ostringstream stream;
+
+	stream << this->name() << "(";
+	stream <<
+		"convexity = " << this->convexity;
+	return stream.str();
+}
+
+void register_builtin_extrude()
+{
+	Builtins::init("extrude", new ExtrudeModule());
+}
diff --git a/src/extrudenode.h b/src/extrudenode.h
new file mode 100644
index 00000000..fe7acd3d
--- /dev/null
+++ b/src/extrudenode.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "node.h"
+#include "value.h"
+
+class ExtrudeNode : public AbstractPolyNode
+{
+public:
+	VISITABLE();
+	ExtrudeNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {
+		convexity = 0;
+	}
+	std::string toString() const override;
+	std::string name() const override { return "extrude"; }
+
+	int convexity;
+};
diff --git a/src/feature.cc b/src/feature.cc
index 774545c6..ab8fd2bd 100644
--- a/src/feature.cc
+++ b/src/feature.cc
@@ -21,6 +21,7 @@ Feature::list_t Feature::feature_list;
  */
 const Feature Feature::ExperimentalSvgImport("svg-import", "Enable SVG import.");
 const Feature Feature::ExperimentalInputDriverDBus("input-driver-dbus", "Enable DBus input drivers (requires restart)");
+const Feature Feature::ExperimentalExtrude("extrude", "Enable extrude() and some extra related changes");
 
 Feature::Feature(const std::string &name, const std::string &description)
 	: enabled(false), name(name), description(description)
diff --git a/src/feature.h b/src/feature.h
index 6517474e..4c8b5b7b 100644
--- a/src/feature.h
+++ b/src/feature.h
@@ -17,6 +17,7 @@ public:
         static const Feature Experimental3dPrint;
         static const Feature ExperimentalSvgImport;
         static const Feature ExperimentalInputDriverDBus;
+        static const Feature ExperimentalExtrude;
 
 	const std::string& get_name() const;
 	const std::string& get_description() const;
diff --git a/src/localscope.cc b/src/localscope.cc
index ad6f6fec..bcc3e303 100644
--- a/src/localscope.cc
+++ b/src/localscope.cc
@@ -7,6 +7,7 @@
 #include "function.h"
 #include "annotation.h"
 #include "UserModule.h"
+#include "node.h"
 
 LocalScope::LocalScope()
 {
@@ -65,7 +66,19 @@ std::vector<AbstractNode*> LocalScope::instantiateChildren(const Context *evalct
 	std::vector<AbstractNode*> childnodes;
 	for(const auto &modinst : this->children) {
 		AbstractNode *node = modinst->evaluate(evalctx);
-		if (node) childnodes.push_back(node);
+		if (node) {
+			// GroupNode can pass its children through to parent without an implied union.
+			// This might later be handled by GeometryEvaluator, but for now just completely
+			// remove the GroupNode from the tree.
+			GroupNode *gr= dynamic_cast<GroupNode*>(node);
+			if (gr && !gr->impliedUnion) {
+				childnodes.insert(childnodes.end(), node->children.begin(), node->children.end());
+				node->children.clear();
+				delete node;
+			}
+			else
+				childnodes.push_back(node);
+		}
 	}
 
 	return childnodes;
diff --git a/src/node.h b/src/node.h
index 0cfc3b6d..12a97084 100644
--- a/src/node.h
+++ b/src/node.h
@@ -86,9 +86,11 @@ class GroupNode : public AbstractNode
 {
 public:
 	VISITABLE();
-	GroupNode(const class ModuleInstantiation *mi) : AbstractNode(mi) { }
+	GroupNode(const class ModuleInstantiation *mi) : AbstractNode(mi), impliedUnion(true) { }
 	~GroupNode() { }
 	std::string name() const override;
+	// To maintain back-compat, GroupNode might perform an implied UNION of its children.
+	bool impliedUnion;
 };
 
 /*!
