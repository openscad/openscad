#!/usr/bin/env python3
# -*- coding: utf-8 -*-
r"""
s2p.py - OpenSCAD -> PythonScad converter (revised)
Fixes:
 - robust transformer signatures for optional params (module_def, etc.)
 - generate() defensive about params vs body (prevents dicts leaking into def signature)
 - func_call_block mapped to transform(union(children), args)
 - preserves previous grammar/behavior
 - FIXED: module bodies now generate o1, o2, ... and return union(o1, o2, ...)
 - UPDATED: top-level shapes now use shape1, shape2, ... naming
 - ADDED: ternary operator support (? :)
 - ADDED: array indexing support ([])
 - ADDED: `function` support: converts `function name(...) = expr;` to `def name(...): return expr`
"""
debug=False
from pprint import pprint
from lark import Lark, Transformer, v_args, Token
import argparse
from typing import List
from datetime import datetime

try:
    from graphviz import Digraph
    HAS_GRAPHVIZ = True
except Exception:
    HAS_GRAPHVIZ = False

# --------------------------
# OUTPUT HEADER TEMPLATE
# --------------------------
HEADER = """# PythonSCAD generated file
# Converted from OpenSCAD to PythonSCAD
# Author: Generated by s2p.py
# Date: {date}
# Source: {source_file}

# Project name (source file without extension)
project = "{project_name}"

# Initialize objects dictionary
objs = {{}}

"""

# --------------------------
# GRAMMAR (with ternary and indexing support + function)
# --------------------------
openscad_grammar = r"""
?start: statement*

?statement: non_block_statement
          | if_statement
          | module_invocation_stmt
          | module_def
          | func_def
          | block
comment: COMMENT

module_invocation_stmt: chainable_call statement_terminator? -> module_invocation_stmt

chainable_call: func_call chainable_call -> chain_continue
              | func_call                 -> chain_end

?statement_terminator: block
                     | ";"

assignment: NAME "=" expr ";"
include_stmt: "include" (ANGLE_STRING | STRING) (";" | COMMENT )? COMMENT?
use_stmt: "use" (ANGLE_STRING | STRING) ";"
module_def: "module" NAME "(" param_list? ")" block
func_def: "function" NAME "(" param_list? ")" "=" expr ";"
block: "{" statement* "}"

for_loop: "for" "(" NAME "=" range_expr ")" block

if_statement: "if" "(" expr ")" body else_clause?

else_clause: "else" if_statement -> else_if
           | "else" body        -> else_block

?body: block
     | module_invocation_stmt

?non_block_statement: assignment
                    | include_stmt
                    | use_stmt
                    | for_loop
                    | comment
                    | ";"
func_call: NAME "(" arg_list? ")"
param_list: param ("," param)*
param: NAME ("=" expr)?
arg_list: argument ("," argument)*
argument: NAME "=" expr -> named_arg
        | expr -> positional_arg

range_expr: "[" expr ":" expr ":" expr "]" -> range_with_step
          | "[" expr ":" expr "]" -> range_no_step

?expr: expr "?" expr ":" expr -> ternary
     | expr "||" expr -> logical_or
     | expr "&&" expr -> logical_and
     | expr "==" expr -> eq
     | expr "!=" expr -> ne
     | expr "<=" expr -> le
     | expr ">=" expr -> ge
     | expr "<" expr -> lt
     | expr ">" expr -> gt
     | expr "+" expr -> add
     | expr "-" expr -> sub
     | expr "%" expr -> mod
     | term

?term: term "*" factor -> mul
     | term "/" factor -> div
     | factor

?factor: "-" factor -> neg
       | "!" factor -> not
       | atom

?atom: atom "[" expr "]" -> index
     | NUMBER -> number
     | vector
     | func_call
     | NAME -> var
     | "(" expr ")"
     | "true" -> true
     | "false" -> false
     | STRING -> string

vector: "[" "]" -> empty_vector
      | "[" expr ("," expr)* "]" -> vector_items
      | comment

ANGLE_STRING: "<" /[^>]+/ ">"
NAME: /\$?[A-Za-z_][A-Za-z0-9_]*/
COMMENT: /\/\/[^\n]*/ | /\/\*[\s\S]*?\*\//
%import common.ESCAPED_STRING -> STRING
%import common.SIGNED_NUMBER -> NUMBER
%import common.WS
%ignore COMMENT
%ignore WS
"""

parser = Lark(openscad_grammar, parser="lalr", propagate_positions=False, maybe_placeholders=False)


# --------------------------
# TRANSFORMER - robust optional args handling
# --------------------------
@v_args(inline=True)
class SCADTransformer(Transformer):
    def strip_dollar(self, tok):
        s = str(tok)
        return s[1:] if s.startswith("$") else s

    def start(self, *items):
        return [i for i in items if i is not None]

    # comments
    def comment(self, token):
        s = str(token).strip()
        # Convert single-line comments
        if s.startswith("//"):
            return {"type": "comment", "text": s}
        # Convert multi-line comments
        elif s.startswith("/*") and s.endswith("*/"):
            return {"type": "comment", "text": s}
        return {"type": "comment", "text": s}

    # statements
    def assignment(self, name, expr):
        return {"type": "assign", "name": self.strip_dollar(name), "value": expr}

    def include_stmt(self, *parts):
        # parts kan 1, 2 of 3 elementen bevatten
        p = parts[0]   # eerste element is het pad
        s = str(p)
        if s.startswith("<") and s.endswith(">"):
            s = s[1:-1]
        elif s.startswith('"') and s.endswith('"'):
            s = s[1:-1]
        if s.lower().endswith('.scad'):
            s = s[:-5]
        return {"type": "include", "file": s.replace("/", ".")}


    def use_stmt(self, path_token):
        s = str(path_token)
        if s.startswith("<") and s.endswith(">"):
            s = s[1:-1]
        elif s.startswith('"') and s.endswith('"'):
            s = s[1:-1]
        if s.lower().endswith(".scad"):
            s = s[:-5]
        s = s.replace("\\", ".").replace("/", ".")
        return {"type": "include", "file": s}

    # module_def: sometimes called as module_def(name, block) when params omitted.
    def module_def(self, name, *args):
        nm = self.strip_dollar(name)
        # args can be: (param_list, block) or (block,)
        params_list = []
        block = []
        if len(args) == 1:
            # only block
            block = args[0] if args[0] else []
        elif len(args) >= 2:
            params_candidate = args[0]
            block = args[1] if args[1] else []
            if isinstance(params_candidate, list):
                params_list = params_candidate
            else:
                params_list = [params_candidate]
        return {"type": "module", "name": nm, "params": params_list, "body": block}

    # function definition handler
    def func_def(self, name, *args):
        nm = self.strip_dollar(name)
        # args can be: (param_list, expr) or (expr,)
        params_list = []
        expr = None
        if len(args) == 1:
            expr = args[0]
        elif len(args) >= 2:
            params_candidate = args[0]
            expr = args[1]
            if isinstance(params_candidate, list):
                params_list = params_candidate
            else:
                params_list = [params_candidate]
        return {"type": "function", "name": nm, "params": params_list, "expr": expr}

    def param_list(self, *params):
        return list(params)

    def param(self, name, default=None):
        nm = self.strip_dollar(name)
        if default is not None:
            return {"name": nm, "default": default}
        return nm

    def block(self, *stmts):
        return [s for s in stmts if s is not None]

    def for_loop(self, varname, rng, block):
        return {"type": "for", "var": self.strip_dollar(varname), "range": rng, "body": block}

    def range_with_step(self, start, step, end):
        return {"start": start, "step": step, "end": end}

    def range_no_step(self, start, end):
        return {"start": start, "step": 1, "end": end}

    def if_statement(self, cond, if_block, else_block=None):
        return {"type": "if", "cond": cond, "if_body": if_block, "else_body": else_block}

    # func calls
    def func_call(self, name, args=None):
        nm = self.strip_dollar(name)
        args_list = args if args else []
        return {"type": "func_call", "name": nm, "args": args_list}

    def arg_list(self, *args):
        return list(args)

    def named_arg(self, name, expr):
        return {"type": "named_arg", "name": self.strip_dollar(name), "value": expr}

    def positional_arg(self, expr):
        return expr

    # chain handlers
    def chain_end(self, node):
        return [node]

    def chain_continue(self, first, rest):
        rest_list = rest if isinstance(rest, list) else [rest]
        return [first] + rest_list

    def module_invocation_stmt(self, chain, term=None):
        """
        chain: list of func_call dicts
        term: block (list) or Token(';')
        If term is block, attach to last call as func_call_block.
        """
        chain_list = chain if isinstance(chain, list) else [chain]

        if isinstance(term, list):
            # attach block to last element
            if len(chain_list) > 0:
                last = chain_list[-1]
                if isinstance(last, dict) and last.get("type") == "func_call":
                    chain_list[-1] = {
                        "type": "func_call_block",
                        "name": last.get("name", ""),
                        "args": last.get("args", []),
                        "children": term,
                    }
                else:
                    # fallback
                    chain_list.append({
                        "type": "func_call_block",
                        "name": "",
                        "args": [],
                        "children": term,
                    })
            else:
                chain_list = [{
                    "type": "func_call_block",
                    "name": "",
                    "args": [],
                    "children": term,
                }]
            return chain_list

        # semicolon -> keep chain as-is
        return chain_list

    # primitives & exprs
    def vector_items(self, *items):
        return list(items)

    def empty_vector(self):
        return []

    def number(self, token):
        s = str(token)
        if "." in s or "e" in s.lower():
            return float(s)
        return int(s)

    def string(self, tk):
        s = str(tk)
        if (s.startswith('"') and s.endswith('"')) or (s.startswith("'") and s.endswith("'")):
            s = s[1:-1]
        return s

    def var(self, name):
        return {"type": "var", "name": self.strip_dollar(name)}

    def true(self):
        return True

    def false(self):
        return False

    # binops/unary
    def eq(self, a, b):
        return {"type": "binop", "op": "==", "left": a, "right": b}
    def ne(self, a, b):
        return {"type": "binop", "op": "!=", "left": a, "right": b}
    def lt(self, a, b):
        return {"type": "binop", "op": "<", "left": a, "right": b}
    def le(self, a, b):
        return {"type": "binop", "op": "<=", "left": a, "right": b}
    def gt(self, a, b):
        return {"type": "binop", "op": ">", "left": a, "right": b}
    def ge(self, a, b):
        return {"type": "binop", "op": ">=", "left": a, "right": b}
    def add(self, a, b):
        return {"type": "binop", "op": "+", "left": a, "right": b}
    def sub(self, a, b):
        return {"type": "binop", "op": "-", "left": a, "right": b}
    def mul(self, a, b):
        return {"type": "binop", "op": "*", "left": a, "right": b}
    def div(self, a, b):
        return {"type": "binop", "op": "/", "left": a, "right": b}
    def neg(self, a):
        return {"type": "unary", "op": "-", "value": a}

    # ternary operator
    def ternary(self, cond, true_val, false_val):
        return {"type": "ternary", "cond": cond, "true": true_val, "false": false_val}

    # array indexing
    def index(self, obj, idx):
        return {"type": "index", "object": obj, "index": idx}


# --------------------------
# Helpers / maps
# --------------------------
CALL_STYLE = {
    "translate": "both",
    "rotate": "both",
    "color": "both",
    "mvx": "both",
    "mvy": "both",
    "mvz": "both",
    "mv": "both",
}

def get_call_style(name: str) -> str:
    return CALL_STYLE.get(name, "function_only")

NAME_MAP = {
    "cube": "cube",
    "sphere": "sphere",
    "cylinder": "cylinder",
    "polyhedron": "polyhedron",
    "union": "union",
    "difference": "difference",
    "intersection": "intersection",
    "translate": "translate",
    "rotate": "rotate",
    "scale": "scale",
    "color": "color",
    "mirror": "mirror",
    "mv": "mv",
    "mvx": "mvx",
    "mvy": "mvy",
    "mvz": "mvz",
    "rotz": "rotz",
    "pipe": "pipe",
}

def mapped_name(n: str) -> str:
    return NAME_MAP.get(n, n)

TRANSFORM_NAMES = {"translate", "rotate","color", "scale", "mvx", "mvy", "mvz", "mv", "mirror", "rotz"}

def is_transform(node):
    return (
        isinstance(node, dict)
        and node.get("type") in ("func_call", "func_call_block")
        and node.get("name") in TRANSFORM_NAMES
    )

# --------------------------
# Expression formatting
# --------------------------
def fmt_number(x):
    if isinstance(x, int):
        return str(x)
    if isinstance(x, float):
        return str(int(x)) if x.is_integer() else repr(x)
    return str(x)

def format_expr(node):
    if node is None:
        return ""
    if isinstance(node, bool):
        return "True" if node else "False"
    if isinstance(node, (int, float)):
        return fmt_number(node)
    if isinstance(node, str):
        return repr(node)
    if isinstance(node, list):
        return "[" + ", ".join(format_expr(x) for x in node) + "]"
    if isinstance(node, dict):
        t = node.get("type")
        if t == "var":
            return node["name"]
        if t == "named_arg":
            return f"{node['name']}={format_expr(node['value'])}"
        if t == "binop":
            L = format_expr(node["left"])
            R = format_expr(node["right"])
            return f"({L} {node['op']} {R})"
        if t == "unary":
            return f"(-{format_expr(node['value'])})"
        if t == "ternary":
            cond = format_expr(node["cond"])
            true_val = format_expr(node["true"])
            false_val = format_expr(node["false"])
            return f"({true_val} if {cond} else {false_val})"
        if t == "index":
            obj = format_expr(node["object"])
            idx = format_expr(node["index"])
            return f"{obj}[{idx}]"
        if t == "func_call":
            name = mapped_name(node["name"])
#            print(f"func: {node}")
            args_s = ", ".join(format_expr(a) for a in node.get("args", []))
            return f"{name}({args_s})"
        if t == "func_call_block":
#            print(f"func_call: {node}")
            # placeholder representation for nested printing
            name = mapped_name(node["name"])
            args_s = ", ".join(format_expr(a) for a in node.get("args", []))
            return f"{name}(<children>{', ' + args_s if args_s else ''})"
    return str(node)


# --------------------------
# Collapse transform sequences
# --------------------------
def is_simple_expr(code: str) -> bool:
    return bool(code) and ("\n" not in code)

def collapse_transform_sequence_old(nodes: List, start_idx: int, in_module: bool = False):
    i = start_idx
    n = len(nodes)
    transforms = []
    while i < n and is_transform(nodes[i]):
        transforms.append(nodes[i])
        i += 1

    if i >= n:
        pieces = []
        for tr in transforms:
            args_s = ", ".join(format_expr(a) for a in tr.get("args", []))
            pieces.append(f"{mapped_name(tr['name'])}({args_s})")
        return ("; ".join(pieces), i)

    child = nodes[i]
    current = generate(child, in_module=in_module)

    first = True
    for tr in reversed(transforms):
        name = tr["name"]
        style = get_call_style(name)
        pname = mapped_name(name)
        params_s = ", ".join(format_expr(a) for a in tr.get("args", []))

        if first:
            if style == "method_only":
                current = (
                    f"{current}.{pname}({params_s})"
                    if is_simple_expr(current)
                    else f"({current}).{pname}({params_s})"
                )
            else:
                current = (
                    f"{pname}({current}, {params_s})"
                    if params_s
                    else f"{pname}({current})"
                )
            first = False
        else:
            if style in ("both", "method_only"):
                current = (
                    f"{current}.{pname}({params_s})"
                    if is_simple_expr(current)
                    else f"({current}).{pname}({params_s})"
                )
            else:
                current = (
                    f"{pname}({current}, {params_s})"
                    if params_s
                    else f"{pname}({current})"
                )

    return (current, i + 1)

def collapse_transform_sequence(nodes: List, start_idx: int, in_module: bool = False):
    i = start_idx
    n = len(nodes)
    transforms = []

    # Collect ALL transforms in the chain
    while i < n and is_transform(nodes[i]):
        transforms.append(nodes[i])
        i += 1

    # If we only have transforms and no child, just chain them
    if i >= n or len(transforms) == 0:
        if len(transforms) == 0:
            return ("", start_idx)

        # Build nested transform calls from right to left
        # Start with the last transform
        current = None
        for tr in reversed(transforms):
            pname = mapped_name(tr['name'])
            params_s = ", ".join(format_expr(a) for a in tr.get("args", []))

            if current is None:
                # Innermost transform without a child
                current = f"{pname}({params_s})" if params_s else f"{pname}()"
            else:
                # Wrap previous transform
                if params_s:
                    current = f"{pname}({current}, {params_s})"
                else:
                    current = f"{pname}({current})"

        return (current, i)

    # We have transforms followed by a non-transform child
    child = nodes[i]
    current = generate(child, in_module=in_module)

    # Apply transforms from innermost to outermost (reverse order)
    for tr in reversed(transforms):
        name = tr["name"]
        style = get_call_style(name)
        pname = mapped_name(name)
        params_s = ", ".join(format_expr(a) for a in tr.get("args", []))

        if style == "method_only":
            current = (
                f"{current}.{pname}({params_s})"
                if is_simple_expr(current)
                else f"({current}).{pname}({params_s})"
            )
        else:
            # Function style: transform(child, params)
            current = (
                f"{pname}({current}, {params_s})"
                if params_s
                else f"{pname}({current})"
            )

    return (current, i + 1)
# --------------------------
# Main generator - UPDATED for shape1, shape2, ... naming at top level
# --------------------------

# --------------------------
# Normalizer for leftover Lark Trees in if/else structures
# --------------------------
from lark import Tree

def normalize_if(node):
    """Normalize leftover Lark Trees in if/else branches to plain Python lists/dicts."""
    if isinstance(node, Tree):
        return [normalize_if(c) for c in node.children]

    if isinstance(node, dict):
        out = {}
        for k, v in node.items():
            if k in ("if_body", "else_body"):
                if v is None:
                    out[k] = None
                elif isinstance(v, Tree):
                    out[k] = normalize_if(v)
                elif isinstance(v, list):
                    out[k] = [normalize_if(x) for x in v]
                else:
                    out[k] = normalize_if(v)
            else:
                out[k] = normalize_if(v)
        return out

    if isinstance(node, list):
        return [normalize_if(x) for x in node]

    return node

def generate(node, in_module=False, obj_counter=None) -> str:
    node = normalize_if(node)
    if obj_counter is None:
        obj_counter = {"count": 0}
    if node is None:
        return ""

    if isinstance(node, list):
        out_lines = []
        i = 0
        while i < len(node):
            cur = node[i]

            # Transform chains
            if is_transform(cur) and (i + 1) < len(node):
                combined, next_idx = collapse_transform_sequence(node, i)
                if not in_module:
                    # Top level: assign directly to objs dict
                    shape_name = f"shape{obj_counter['count']}"
                    out_lines.append(f"objs['{shape_name}'] = {combined}")
                else:
                    # Inside module: use o prefix
                    out_lines.append(combined)
                i = next_idx
                continue

            # Normal func_call â†’ assign to objs or oX (only at top level, not in modules)
            if isinstance(cur, dict) and cur.get("type") in ("func_call", "func_call_block") and not in_module:
                expr = generate(cur, in_module=in_module, obj_counter=obj_counter)
                obj_counter["count"] += 1
                shape_name = f"shape{obj_counter['count']}"
                out_lines.append(f"objs['{shape_name}'] = {expr}")
                i += 1
                continue

            # Default
            out_lines.append(generate(cur, in_module=in_module, obj_counter=obj_counter))
            i += 1

        return "\n".join(s for s in out_lines if s.strip())

    if not isinstance(node, dict):
        if isinstance(node, bool):
            return "True" if node else "False"
        if isinstance(node, (int, float)):
            return fmt_number(node)
        if isinstance(node, str):
            return node
        if isinstance(node, list):
            return "[" + ", ".join(format_expr(x) for x in node) + "]"
        return str(node)

    t = node.get("type")

    if t == "include":
        return f"from {node['file']} import *"

    if t == "comment":
        text = node.get("text", "")
        # Convert multi-line /* */ to Python multi-line comments
        if text.startswith("/*") and text.endswith("*/"):
            content = text[2:-2].strip()
            lines = content.split("\n")
            if len(lines) == 1:
                return f"# {lines[0]}"
            else:
                return "\n".join(f"# {line.strip()}" for line in lines)
        # Single-line // comments
        elif text.startswith("//"):
            return f"#{text[2:]}"
        return f"# {text}"

    if t == "assign":
        name = node["name"]
        val = format_expr(node["value"])
        return f"{name} = {val}"

    if t == "var":
        return node["name"]

    if t in ("binop", "unary", "ternary", "index"):
        return format_expr(node)

    if t == "module":
        name = node["name"]

        # Defensive handling: ensure params contains only parameter descriptors
        raw_params = node.get("params", []) or []
        raw_body = node.get("body", []) or []

        params_list = []
        body_items = list(raw_body)

        for p in raw_params:
            if isinstance(p, dict) and "name" not in p:
                body_items.insert(0, p)
            else:
                params_list.append(p)

        # Format params for signature
        sig_params = []
        for p in params_list:
            if isinstance(p, dict) and "name" in p:
                if "default" in p:
                    sig_params.append(f"{p['name']}={format_expr(p['default'])}")
                else:
                    sig_params.append(p['name'])
            elif isinstance(p, str):
                sig_params.append(p)
            else:
                sig_params.append(str(p))

        params_sig = ", ".join(sig_params)

        # Reset counter for this module
        local_counter = {"count": 0}

        # Generate body expressions with o1, o2, ... pattern (inside modules)
        body_exprs = []
        for b in body_items:
            expr = generate(b, in_module=True, obj_counter=local_counter)
            if expr and expr.strip():
                body_exprs.append((expr, b.get("type") if isinstance(b, dict) else None))

        # Build function with PythonSCAD pattern
        lines = [f"def {name}({params_sig}):"]

        if len(body_exprs) == 0:
            lines.append("    return None")
        else:
            # Process all expressions and collect object names
            obj_names = []
            for expr, expr_type in body_exprs:
                # Comments and assignments should be kept as-is
                if expr_type == "comment":
                    lines.append(f"    {expr}")
                elif expr_type == "assign":
                    lines.append(f"    {expr}")
                elif "\n" in expr:
                    # multiline expression (like for loop) - just add it
                    for line in expr.splitlines():
                        lines.append("    " + line)
                else:
                    # Single line expression - assign to oX
                    local_counter["count"] += 1
                    obj_name = f"o{local_counter['count']}"
                    lines.append(f"    {obj_name} = {expr}")
                    obj_names.append(obj_name)

            # Final return statement
            if len(obj_names) == 0:
                lines.append("    return None")
            elif len(obj_names) == 1:
                lines.append(f"    return {obj_names[0]}")
            else:
                obj_list = ", ".join(obj_names)
                lines.append(f"    return union({obj_list})")

        return "\n".join(lines)

    if t == "function":
        # Convert OpenSCAD function to Python def ...: return ...
        name = node["name"]

        # Defensive param handling
        raw_params = node.get("params", []) or []
        sig_params = []
        for p in raw_params:
            if isinstance(p, dict) and "name" in p:
                if "default" in p:
                    sig_params.append(f"{p['name']}={format_expr(p['default'])}")
                else:
                    sig_params.append(p['name'])
            elif isinstance(p, str):
                sig_params.append(p)
            else:
                sig_params.append(str(p))
        params_sig = ", ".join(sig_params)

        expr = node.get("expr")
        expr_s = format_expr(expr)

        lines = []
        lines.append(f"def {name}({params_sig}):")
        lines.append(f"    return {expr_s}")
        return "\n".join(lines)

    if t == "func_call":
        fname = node["name"]
        args = node.get("args", [])
        args_s = ", ".join(format_expr(a) for a in args)
        return f"{mapped_name(fname)}({args_s})"

    if t == "func_call_block":
        # transform(children, args...) style
        fname = node["name"]
        args = node.get("args", [])
        children = node.get("children", [])

        # Generate children
        if in_module:
            # Inside module: generate children directly as expressions without assignments
            child_exprs = []
            for c in children:
                expr = generate(c, in_module=True, obj_counter=obj_counter)
                if expr and expr.strip():
                    child_exprs.append(expr)
        else:
            # Top level: children are already in objs
            child_exprs = []
            for c in children:
                expr = generate(c, in_module=False, obj_counter=obj_counter)
                if expr and expr.strip():
                    child_exprs.append(expr)

        if len(child_exprs) == 0:
            child_code = "None"
        elif len(child_exprs) == 1:
            child_code = child_exprs[0]
        else:
            # Multiple children
            child_code = f"union({', '.join(child_exprs)})"

        pname = mapped_name(fname)
        args_s = ", ".join(format_expr(a) for a in args)
        if args_s:
            return f"{pname}({child_code}, {args_s})"
        else:
            return f"{pname}({child_code})"

    if t == "for":
        var = node["var"]
        rng = node["range"]
        start = format_expr(rng["start"])
        step = format_expr(rng["step"])
        end = format_expr(rng["end"])
        body_items = node.get("body", [])

        # Check if we're in a module context - if so, generate list comprehension style
        if in_module:
            # Generate list comprehension for inline usage
            # Process body items to get expressions
            body_exprs = []
            for b in body_items:
                expr = generate(b, in_module=True, obj_counter=obj_counter)
                if expr and expr.strip():
                    body_exprs.append(expr)

            if len(body_exprs) == 1:
                body_expr = body_exprs[0]
                return f"[{body_expr} for {var} in range({start}, {end} + {step}, {step})]"
            else:
                # Multiple items in body - wrap in union
                body_union = f"union({', '.join(body_exprs)})"
                return f"[{body_union} for {var} in range({start}, {end} + {step}, {step})]"
        else:
            # Top-level for loop - generate with objs dict assignment
            body_exprs = []
            for b in body_items:
                expr = generate(b, in_module=False, obj_counter=obj_counter)
                if expr and expr.strip():
                    body_exprs.append(expr)

            if obj_counter:
                obj_counter["count"] += 1
                shape_name = f"shape{obj_counter['count']}"
            else:
                shape_name = "shape1"

            lines = []
            lines.append("temp_objs = []")
            lines.append(f"for {var} in range({start}, {end} + {step}, {step}):")
            for expr in body_exprs:
                lines.append(f"    temp_objs.append({expr})")
            lines.append(f"objs['{shape_name}'] = union(*temp_objs)")
            return "\n".join(lines)

    if t == "if":
        cond = format_expr(node["cond"])
        if_body = node.get("if_body", [])
        else_body = node.get("else_body")
        lines = []
        lines.append(f"if {cond}:")
        for b in if_body:
            lines.append(f"    {generate(b, in_module=in_module, obj_counter=obj_counter)}")
        if else_body:
            lines.append("else:")
            for b in else_body:
                lines.append(f"    {generate(b, in_module=in_module, obj_counter=obj_counter)}")
        return "\n".join(lines)

    return ""



# --------------------------
# AST visualizer
# --------------------------
def ast_to_graph(ast, graph=None, parent=None, nid=None):
    if nid is None:
        nid = [0]
    if graph is None:
        if not HAS_GRAPHVIZ:
            raise ImportError("graphviz module not available")
        graph = Digraph()

    if ast is None:
        return graph

    node_id = str(nid[0])
    nid[0] += 1

    if isinstance(ast, dict):
        label = ast.get("type", "node")
        if "name" in ast:
            label += f"\\n{ast['name']}"
    elif isinstance(ast, list):
        label = "list"
    else:
        label = str(ast)

    graph.node(node_id, label)
    if parent is not None:
        graph.edge(parent, node_id)

    if isinstance(ast, dict):
        for k, v in ast.items():
            if k in ("type", "name"):
                continue
            if isinstance(v, list):
                for child in v:
                    ast_to_graph(child, graph, node_id, nid)
            else:
                ast_to_graph(v, graph, node_id, nid)
    elif isinstance(ast, list):
        for child in ast:
            ast_to_graph(child, graph, node_id, nid)

    return graph


# --------------------------
# Convert helper + CLI
# --------------------------
def convert(src: str, source_file: str = "unknown"):
    """
    Convert OpenSCAD source code to PythonSCAD code.

    Args:
        src: OpenSCAD source code as string
        source_file: Name of the source file for header documentation

    Returns:
        tuple: (ast, code) where ast is the parsed tree and code is the generated Python code
    """
    import os
    import fnmatch

    # Parse the OpenSCAD source
    print ("**** start tree = pars(src) ****")
    tree = parser.parse(src)
    if debug: pprint(tree)
    # Transform to AST
    print ("**** start transform to ast****")
    ast = SCADTransformer().transform(tree)
    if debug: pprint(ast)
    # Generate PythonSCAD code
    print ("**** start generate PythonScad cod) ****")
    code = generate(ast)

    # Extract project name from source file (filename without extension)
    project_name = os.path.splitext(os.path.basename(source_file))[0]

    # Prepend header with current date, source file, and project name
    header = HEADER.format(
        date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        source_file=source_file,
        project_name=project_name
    )

    # Collect all module/function names from AST
    module_names = []
    function_names = []

    if isinstance(ast, list):
        for item in ast:
            if isinstance(item, dict):
                if item.get("type") == "module":
                    module_names.append(item.get("name"))
                elif item.get("type") == "function":
                    function_names.append(item.get("name"))

    # Filter module names based on show_objects patterns
    # Default patterns from header
    show_patterns = ["main", project_name]

    filtered_modules = []
    for pattern in show_patterns:
        for name in module_names:
            if fnmatch.fnmatch(name, pattern):
                if name not in filtered_modules:
                    filtered_modules.append(name)

    # Generate footer to add modules to objs and call show()
    footer = generate_show_function(filtered_modules)

    code = header + code + "\n" + footer

    return ast, code


def generate_show_function(module_names):
    """
    Generate code to add modules to objs and call the PythonSCAD show() function.
    Shapes are already added directly to objs during code generation.

    Args:
        module_names: List of module/function names to call and add to objs (already filtered)

    Returns:
        str: Python code for adding modules and calling show()
    """
    lines = []
    lines.append("")
    lines.append("# Add modules to objects dictionary")

    # Add all found modules to objs dictionary (already filtered by converter)
    for name in module_names:
        lines.append(f"objs['{name}'] = {name}()")

    lines.append("")
    lines.append("# Display all collected objects")
    lines.append("show(objs)")
    lines.append("")

    return "\n".join(lines)


def print_ascii_ast(a, indent=0):
    sp = "  " * indent
    if isinstance(a, list):
        for it in a:
            print_ascii_ast(it, indent)
        return
    if not isinstance(a, dict):
        print(sp + repr(a))
        return
    print(sp + f"{a.get('type')}:")
    for k, v in a.items():
        if k == "type":
            continue
        print(sp + f"  {k}:")
        print_ascii_ast(v, indent + 2)


def main():
    import black
    ap = argparse.ArgumentParser(
        description="OpenSCAD -> PythonScad converter",
        epilog="Examples:\n"
               "  %(prog)s input.scad              # Convert to input.py\n"
               "  %(prog)s input.scad output.py    # Convert to output.py\n"
               "  %(prog)s input.scad -d           # Show debug AST\n"
               "  %(prog)s input.scad -v           # Generate ast_diagram.png or print ascii AST\n",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    ap.add_argument("input", help="input .scad file")
    ap.add_argument("output", nargs="?", help="output .py file (default: input filename with .py extension)")
    ap.add_argument("-d", "--debug", action="store_true", help="print AST debug information")
    ap.add_argument("-v", "--visualize", action="store_true", help="generate ast_diagram.png or print ascii AST")
    args = ap.parse_args()
    debug==args.debug
    # Determine output filename
    if args.output:
        output_file = args.output
    else:
        # Use input filename with .py extension
        import os
        base_name = os.path.splitext(args.input)[0]
        output_file = base_name + ".py"

    # Read input file
    with open(args.input, "r", encoding="utf-8") as f:
        src = f.read()

    # Parse and convert
    try:
        ast, code = convert(src, source_file=args.input)
    except Exception as e:
        print("Parse error:", e)
        raise

    # Debug output if requested
    if args.debug:
        pprint(ast)

    # Write output file
    with open(output_file, "w", encoding="utf-8") as f:
#        pretty=black.format_str(code,mode=black.Mode())
        f.write(code)
#        f.write(pretty)
    print(f"Wrote {output_file}")
    print(code)

    # Visualization if requested
    if args.visualize:
        if HAS_GRAPHVIZ:
            try:
                g = ast_to_graph(ast)
                g.render("ast_diagram", format="png", cleanup=True)
                print("AST diagram written to ast_diagram.png")
            except Exception as e:
                print("Graphviz failed:", e)
                print("\nASCII fallback:")
                print_ascii_ast(ast)
        else:
            print("Graphviz not available, using ASCII fallback:")
            print_ascii_ast(ast)


if __name__ == "__main__":
    main()
